<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Condensed&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="main.css">

    <title>Document</title>
</head>

<body>
    <div id="app">
        <div class="sidebar">
            <p>{{patientInfo.lastName}}</p>
            <p>{{patientInfo.firstName}} {{patientInfo.middleName}}</p>
            <p>ID {{patientInfo.id}}</p>
            <p>{{patientInfo.gender}}, Age {{patientInfo.age}}</p>
            <div class="sidebar__line"></div>
            <p>Chief Complaint</p>
            <p>{{patient.MeditechEDM.ChiefComplaint}}</p>
            <p>Dietary Restrictions</p>
            <div v-for="restriction in patientDietaryRestrictions.slice(0,3)">
                <p>{{restriction.key}}</p>
                <p>{{fromToday(restriction.value[0].ServiceDate)}}</p>
            </div>
            <p>Current Medications</p>
            <p>Allergies</p>
            <div class="sidebar__line"></div>
            <p>Notes</p>
        </div>
        <div class="main">
            <div class="content">
                <category v-bind:type="0" v-bind:data="patientLaboratories" v-bind:today="today"></category>
                <category v-bind:type="1" v-bind:data="patientImaging" v-bind:today="today"></category>
                <category v-bind:type="2" v-bind:data="patientOthers" v-bind:today="today"></category>
            </div>

            <div class="timeline"></div>
        </div>
    </div>



    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://momentjs.com/downloads/moment.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="fake_patient_data.js"></script>

    <script>
        Vue.mixin({
            methods: {
                momentParseDMY(date) {
                    return moment(date, 'DD-MMMM-YYYY');
                },
                fromToday(date) {
                    return this.momentParseDMY(date).from(this.today);
                },
            }
        });
    </script>

    <script>
        Vue.component('data-card', {
            template: '#data-card-template',
            props: {
                data: Object,
                type: Number,
                today: Object,
            },
            data() {
                return {
                    ordersToShow: 20,
                }
            },
            methods: {

            },
        });
    </script>
    <template id="data-card-template">
        <div class="data-card">
            <p>{{data.key}}</p>
            <p>Last completed {{fromToday(data.value[0].ServiceDate)}}</p>
            <p>{{data.value[0].Category}}</p>
            <p v-if="data.value.length > 1">{{data.value.length}} more past results</p>
            <p v-else>no more results</p>
        </div>
    </template>

    <script>
        Vue.component('category', {
            template: '#category-template',
            props: {
                data: Array,
                type: Number,
                today: Object,
            },
            data() {
                return {
                    searchRaw: '',
                    tagsSelected: [],
                }
            },
            computed: {
                title() {
                    let types = [
                        'Laboratories',
                        'Imaging',
                        'Others',
                    ]
                    return types[this.type];
                },
                mostOftenWord() {
                    let words = [];
                    this.data.forEach(d => {
                        d.value.forEach(d => {
                            words = words.concat(d.Procedure.split(/ |\(|\)|,|-/));
                        });

                    });

                    // remove blank words
                    words = words.filter(d => d !== '' && d.length > 2);

                    // words = words.map(d => d.toLowerCase());

                    let grouped = d3.nest()
                        .key(d => d)
                        .rollup(d => d.length)
                        .entries(words);

                    grouped.sort((a, b) => b.value - a.value);

                    return grouped;
                },
                search() {
                    return this.searchRaw.trim().toLowerCase();
                },
                filteredData() {
                    let filtered = this.data.filter(d => {
                        let tagMatched = false;
                        this.tagsSelected.forEach(tag => {
                            let lowerCase = tag.toLowerCase();
                            if (d.key.toLowerCase().includes(lowerCase)) {
                                tagMatched = true;
                            }
                            if (d.value[0].Category.toLowerCase().includes(lowerCase)) {
                                tagMatched = true;
                            }
                        });

                        
                        let searched = false;
                        if (d.key.toLowerCase().includes(this.search)) {
                            searched = true;
                        }
                        if (d.value[0].Category.toLowerCase().includes(this.search)) {
                            searched = true;
                        }

                        if (this.tagsSelected.length > 0) {
                            return tagMatched && searched;
                        } else {
                            return searched;
                        }
                        
                    });
                    return filtered;
                }
            },
            methods: {
                toggleTag(tag) {
                    let tagIndex = this.tagsSelected.indexOf(tag)
                    if (tagIndex > -1) {
                        delete this.tagsSelected.splice(tagIndex, 1);
                    } else {
                        this.tagsSelected.push(tag);
                    }
                }
            },
        });
    </script>
    <template id="category-template">
        <div class="category">
            <p>{{title}}</p>
            <div class="filter">
                <input class="filter__input" placeholder="Search" v-model="searchRaw">
                <div v-bind:class="[{'filter__tags' : true, 'filter__tags_selected' : tagsSelected.indexOf(tag.key) > -1}]"
                    v-for="tag in mostOftenWord.slice(0,15)" v-on:click="toggleTag(tag.key)">{{tag.key}}</div>
            </div>
            <div class="category__cards-con">
                <div class="category__scroll">
                    <data-card v-for="(item, index) in filteredData" v-bind:data="item" v-bind:key="item.key"
                        v-bind:type="type" v-bind:today="today"></data-card>
                </div>
            </div>
        </div>
    </template>

    <script>
        new Vue({
            el: '#app',
            data: {
                doctor: {
                    firstName: "Jorge",
                    middleName: "L.",
                    lastName: "Weaver",
                    type: "Physician",
                    id: "03578115",
                },
                patients: patients,
            },
            computed: {
                patient() {
                    return patients[0];
                },
                today() {
                    return moment("2031 02 20", "YYYY MM DD");
                },
                patientOrderHistory() {
                    return this.patient.OrderEntry.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.ServiceDate).format('x');
                        return (dateB - dateA);
                    });
                },
                patientInfo() {

                    let birthDate = this.momentParseDMY(this.patient.Info.Birthday);
                    let age = this.today.diff(birthDate, 'years');

                    return {
                        firstName: this.patient.Info.FirstName,
                        middleName: this.patient.Info.MiddleName,
                        lastName: this.patient.Info.LastName,
                        id: this.patient.Info.ID,
                        gender: this.patient.Info.Gender,
                        age: age,
                    }
                },
                patientDietaryRestrictions() {
                    let filtered = this.patientOrderHistory.filter(d => d.Category === 'Dietary');

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
                patientLaboratories() {
                    let filtered = this.patientOrderHistory.filter(d => d.Category === 'Laboratory');

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
                patientImaging() {
                    let filtered = this.patientOrderHistory.filter(d => {
                        return (d.Category === 'Computed Tomography' || d.Category === 'Radiography');
                    });

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
                patientOthers() {
                    let filtered = this.patientOrderHistory.filter(d => {
                        return (
                            d.Category !== 'Laboratory' &&
                            d.Category !== 'Computed T' &&
                            d.Category !== 'Radiography'
                        )
                    });

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
            },
        })
    </script>
</body>

</html>