<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Condensed&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="main.css">

    <title>Document</title>
</head>

<body>
    <div id="app">
        <div class="sidebar">
            <p class="sidebar__name-large">{{patientInfo.lastName}}</p>
            <p class="sidebar__name-small">{{patientInfo.firstName}} {{patientInfo.middleName}}</p>
            <p class="sidebar__title">ID {{patientInfo.id}}</p>
            <p class="sidebar__text">{{patientInfo.gender}}, Age {{patientInfo.age}}</p>
            <div class="sidebar__line"></div>
            <p class="sidebar__title">Chief Complaint</p>
            <p class="sidebar__text">{{patient.EDM.ChiefComplaint}}</p>
            <p class="sidebar__title">Dietary Restrictions</p>
            <div v-for="restriction in patientDietaryRestrictions.slice(0,3)">
                <p class="sidebar__text">{{restriction.key}}</p>
                <p class="sidebar__text">{{fromToday(restriction.value[0].ServiceDate)}}</p>
            </div>
            <p class="sidebar__title">Current Medications</p>
            <p class="sidebar__title">Allergies</p>
            <div class="sidebar__line"></div>
            <p class="sidebar__title">Notes</p>
            <input v-model="notesInput" type="text">
            <button @click="patients[patientIndex].notes.push(notesInput)">save</button>
            <p v-for="note in patients[patientIndex].notes">{{note}}</p>
        </div>
        <div class="main">
            <div class="content">
                <div class="tabs">
                    <div v-for="(tab, index) in tabs"
                        :class="{'tabs__button':true, 'tabs__button_selected':tabIndex === index}"
                        @click="tabIndex = index">
                        {{tab}}</div>
                </div>
                <div class="overview" v-show="tabIndex === 0">
                    <category class="category_lab" :type="0" :data="patientLaboratories" :today="today"
                        :patient-index="patientIndex" :others="others">
                    </category>
                    <category class="category_imaging" :type="1" :data="patientImaging" :today="today"
                        :patient-index="patientIndex" :others="others">
                    </category>
                    <category class="category_other" :type="2" :data="patientOthers" :today="today"
                        :patient-index="patientIndex" :others="others">
                    </category>
                </div>
            </div>

            <timeline :data="patient" @chose-date="changeDate" :real-time="realTime" :today="today"
                @reset-date="today = now"></timeline>
        </div>
    </div>



    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://momentjs.com/downloads/moment.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.6.1/fuse.min.js"></script>
    <script src="https://unpkg.com/vue-vega"></script>

    <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>

    <script src="fake_patient_data.js"></script>
    <script src="sample_tests.js"></script>



    <script>
        let randomFromRange = (range) => {
            let rangeValues = range.split('-');
            let min = Math.min(rangeValues[0], rangeValues[1]);
            let max = Math.max(rangeValues[0], rangeValues[1]);
            return ((Math.random() * (max - min)) + min);
        }

        let others = {
            pins: [],
            oldPins: [],
            flags: [],
            oldFlags: [],
        }

        // data cleaning
        patients.forEach(patient => {
            patient.OrderEntry.forEach(entry => {
                if (entry.Category === 'Laboratory' ||
                    entry.Category === 'Computed Tomography' ||
                    entry.Category === 'Radiography' ||
                    entry.Category === 'Ultrasonography') {

                    let results = [];

                    let prams = sample_tests[entry.Procedure];
                    if (prams !== undefined) {
                        prams.forEach(pram => {
                            let result = null;

                            if (pram.type === 'number') {
                                let value = randomFromRange(pram.range);
                                result = {
                                    testValue: pram.testValue,
                                    range: pram.range,
                                    units: pram.units,
                                    value: value.toFixed(2),
                                    type: pram.type,
                                };
                            } else if (pram.type === 'image') {
                                result = {
                                    link: pram.link,
                                    notes: pram.notes,
                                    type: pram.type,
                                };
                            }

                            if (result !== null) {
                                results.push(result)
                            }
                        });
                    } else if (entry.Category === 'Laboratory') {
                        for (let c = 0; c < 4; c++) {
                            let range = '1-10';
                            let value = randomFromRange(range);
                            let result = {
                                testValue: 'fake value ' + c,
                                range: range,
                                units: 'mL/s',
                                value: value.toFixed(2),
                                type: 'number',
                            };
                            results.push(result)
                        }
                    }

                    entry.results = results;
                }
            });

            patient.notes = [];

            others.pins.push([]);
            others.oldPins.push([]);
            others.flags.push([]);
            others.oldFlags.push([]);
        });


        Vue.use(VueVega.default);

        Vue.mixin({
            methods: {
                momentParseDMY(date) {
                    return moment(date, 'DD-MMMM-YYYY');
                },
                momentParseDMYT(date) {
                    return moment(date, 'DD-MMMM-YYYY HH:mm');
                },
                formatDate(date) {
                    return this.momentParseDMY(date).format("MMM Do, YYYY");
                },
                fromToday(date) {
                    return this.momentParseDMY(date).from(this.today);
                },
            }
        });
    </script>

    <script>
        Vue.component('timeline', {
            template: '#timeline-template',
            props: {
                today: Object,
                data: Object,
                realTime: Boolean,
            },
            data() {
                return {
                    hovering: null,
                    screenX: 0,
                    screenY: 0,
                }
            },
            computed: {
                timeData() {
                    let chronologicalData = [];
                    let date = null;
                    let index = 0;

                    date = this.momentParseDMYT(this.data.EDM.ArrivalTime);
                    index = chronologicalData.push(this.data.EDM) - 1;
                    chronologicalData[index].parsedDate = date;
                    chronologicalData[index].from = 'EDM';

                    date = this.momentParseDMYT(this.data.ADM.AdmitTime);
                    index = chronologicalData.push(this.data.ADM) - 1;
                    chronologicalData[index].parsedDate = date;
                    chronologicalData[index].from = 'ADM';

                    this.data.OrderEntry.forEach(d => {
                        let date = this.momentParseDMY(d.ServiceDate);
                        let index = chronologicalData.push(d) - 1;
                        chronologicalData[index].parsedDate = date;
                        chronologicalData[index].from = 'OrderEntry';
                    });
                    this.data.Appointments.forEach(d => {
                        let date = this.momentParseDMY(d.Date);
                        let index = chronologicalData.push(d) - 1;
                        chronologicalData[index].parsedDate = date;
                        chronologicalData[index].from = 'Appointments';
                    });
                    this.data.EDMLocationHistory.forEach(d => {
                        let date = this.momentParseDMYT(d.StartDate);
                        let index = chronologicalData.push(d) - 1;
                        chronologicalData[index].parsedDate = date;
                        chronologicalData[index].from = 'EDMLocationHistory';
                    });
                    this.data.ADMLocationHistory.forEach(d => {
                        let date = this.momentParseDMYT(d.StartDate);
                        let index = chronologicalData.push(d) - 1;
                        chronologicalData[index].parsedDate = date;
                        chronologicalData[index].from = 'ADMLocationHistory';
                    });
                    this.data.Surgeries.forEach(d => {
                        let date = this.momentParseDMYT(d.PatientInRoom);
                        let index = chronologicalData.push(d) - 1;
                        chronologicalData[index].parsedDate = date;
                        chronologicalData[index].from = 'Surgeries';
                    });

                    chronologicalData.sort((a, b) => {
                        return a.parsedDate.unix() - b.parsedDate.unix();
                    });

                    let bundledData = [];
                    let bundleTemplate = {
                        startDate: null,
                        endDate: null,
                        type: '',
                        niceName: '',
                        tileName: '',
                        deltaDays: 0,
                        items: [],
                    };
                    let nameMapping = {
                        EDM: 'Emergency',
                        ADM: 'Transfer to Hospital',
                        OrderEntry: '',
                        Appointments: 'Visited',
                        EDMLocationHistory: 'Room Change',
                        ADMLocationHistory: 'Room Change',
                        Surgeries: 'Surgery',
                    };
                    let titleNameMapping = {
                        EDM: 'Emergency Room Entry',
                        ADM: 'Hospital Entry',
                        OrderEntry: '',
                        Appointments: 'Visited by Doctor',
                        EDMLocationHistory: 'Emergency Room Change',
                        ADMLocationHistory: 'Hospital Room Change',
                        Surgeries: 'Surgery',
                    };
                    let bundle = null;
                    chronologicalData.forEach(d => {
                        if (bundle === null || bundle.type !== d.from) {
                            if (bundle !== null) {
                                bundle.endDate = d.parsedDate;
                                bundle.deltaDays = bundle.endDate.diff(bundle.startDate, 'days');
                                if (bundle.type === 'OrderEntry') {
                                    bundle.niceName = bundle.deltaDays + 'd';
                                    bundle.tileName = bundle.deltaDays + ' day gap';
                                }
                                bundledData.push(bundle);
                            }

                            bundle = JSON.parse(JSON.stringify(bundleTemplate));

                            bundle.type = d.from;
                            bundle.niceName = nameMapping[d.from];
                            bundle.tileName = titleNameMapping[d.from];
                            bundle.startDate = d.parsedDate;
                            bundle.items = [];
                        }
                        bundle.items.push(d);
                    });

                    return bundledData;
                },
            },
            methods: {
                eventClassGen(type) {
                    let classObject = {};
                    classObject['timeline__event'] = true;
                    classObject['timeline__event_' + type] = true;
                    return classObject;
                },
                hover(e) {
                    this.screenX = e.clientX;
                    this.screenY = e.clientY - 10;
                },
                eventClicked(event) {
                    this.$emit('chose-date', event.endDate);
                },
                resetToNow() {
                    this.$emit('reset-date');
                }
            },
            mounted() {
                this.$refs.line.scrollLeft = this.$refs.line.scrollWidth;
            }
        });
    </script>
    <template id="timeline-template">
        <div class="timeline">
            <transition name="fade">
                <div class="timeline__hover" v-if="hovering !== null" ref="hoverBox"
                    :style="{transform: 'translate3d('+screenX+'px, '+screenY+'px, 0px)'}">
                    <div class="timeline__hover-content">
                        <p class="title">{{hovering.tileName}}</p>
                        <p>{{this.formatDate(hovering.startDate)}} - {{this.formatDate(hovering.endDate)}}</p>
                        <p>events: {{hovering.items.length}}</p>
                        <p>from: {{hovering.type}}</p>
                    </div>
                </div>
            </transition>

            <div class="timeline__warning" v-if="!realTime" @click="resetToNow">
                Showing Items Before <strong>{{formatDate(today)}}</strong>. Click to reset
            </div>

            <div class="timeline__main" ref="line">
                <div class="timeline__track">
                    <div :class="eventClassGen(event.type)" v-for="event in timeData" @mouseover="hovering = event"
                        @mouseout="hovering = null" @mousemove="hover" @click="eventClicked(event)">
                        <div>{{event.niceName}}</div>
                    </div>
                </div>
            </div>
        </div>
    </template>

    <script>
        Vue.component('vega', {
            template: '#vega-template',
            props: {
                spec: Object,
            },
            watch: {
                spec: {
                    handler(newSpec, oldSpec) {
                        this.vega(newSpec);
                    },
                    deep: true,
                }
            },
            methods: {
                vega(spec) {
                    this.$refs.graph.innerHtml = "";
                    vegaEmbed.embed(this.$refs.graph, spec, {
                        actions: false,
                        renderer: 'svg',
                    });
                }
            },
            mounted() {
                this.vega(this.spec);
            }
        });
    </script>
    <template id="vega-template">
        <div class="vega" ref="graph"></div>
    </template>


    <script>
        Vue.component('data-card', {
            template: '#data-card-template',
            props: {
                data: Object,
                type: Number,
                today: Object,
                index: Number,
                patientIndex: Number,
                others: Object,
            },
            data() {
                return {
                    collapsed: true,
                }
            },
            watch: {
                index(newIndex) {
                    this.checkIndex();
                },
            },
            computed: {
                dateMin() {
                    return this.today.clone().subtract(2, 'month');
                },
                dateMax() {
                    return this.today;
                },
                numIsShowing() {
                    return this.data.value.filter(d => {
                        return d.parsedDate.isBetween(this.dateMin, this.dateMax);
                    }).length;
                },
                numNotShowing() {
                    return (this.data.value.length) - this.numIsShowing;
                },
                name() {
                    return this.data.key;
                },
                vegaSpec() {

                    let min = this.dateMin;
                    let max = this.dateMax;

                    return {
                        background: 'transparent',
                        config: {
                            view: {
                                stroke: "transparent"
                            }
                        },
                        mark: {
                            type: "line",
                            interpolate: "monotone",
                            strokeWidth: .75,
                            stroke: '#1F1424',
                            clip: true,
                            point: {
                                filled: true,
                                stroke: "white",
                                strokeWidth: 1,
                                size: 20,
                            },
                        },
                        data: { values: null },
                        width: 'container',
                        height: 'container',
                        padding: 0,
                        encoding: {
                            x: {
                                field: 'date',
                                type: 'temporal',
                                axis: null,
                                scale: {
                                    domain: [
                                        {
                                            year: parseInt(min.format('YYYY')),
                                            month: parseInt(min.format('MM')),
                                            date: parseInt(min.format('DD')),
                                        },
                                        {
                                            year: parseInt(max.format('YYYY')),
                                            month: parseInt(max.format('MM')),
                                            date: parseInt(max.format('DD')),
                                        }
                                    ]
                                }
                            },
                            y: {
                                field: 'delta',
                                type: 'quantitative',
                                axis: null,
                                scale: {
                                    padding: 2,
                                }
                            },
                            color: {
                                value: '#1F1424',
                                condition: {
                                    test: 'datum["outOfRange"]',
                                    value: '#C44536',
                                }
                            },
                            tooltip: [
                                { field: "value", type: "quantitative" },
                                { field: "delta", type: "quantitative" },
                                { field: "date", type: "temporal" },
                            ]
                        },
                    }
                },
                latest() {
                    return this.data.value[0];
                },
                graphData() {
                    let data = [];
                    if (this.latest.results !== undefined) {
                        this.latest.results.forEach((d, index) => {
                            let resultData = [];
                            this.data.value.forEach(d => {

                                let result = d.results[index];
                                if (result.type === 'number') {

                                    let delta = this.latest.results[index].value - result.value;

                                    let range = result.range.split('-');
                                    let min = Math.min(range[0], range[1]);
                                    let max = Math.max(range[0], range[1]);
                                    let maxDelta = (max - min) / 30;

                                    resultData.push({
                                        delta: delta,
                                        value: result.value,
                                        date: d.ServiceDate,
                                        outOfRange: result.value < min + maxDelta || result.value > max - maxDelta,
                                    });
                                }
                            });
                            data.push(resultData);
                        });


                    }
                    return data;
                },
                warnValues() {
                    return this.graphData.map(d => {
                        let latest = d[0];
                        if (latest !== undefined && latest.outOfRange !== undefined) {
                            return (latest.outOfRange ? true : false);
                        } else {
                            return false;
                        }
                    });
                },
                warn() {
                    return this.warnValues.reduce((a, d) => {
                        if (d) {
                            return true;
                        } else {
                            return a;
                        }
                    }, false);
                },
                pined() {
                    return this.others.pins[this.patientIndex].indexOf(this.name) > -1;
                },
                flagged() {
                    return this.others.flags[this.patientIndex].indexOf(this.name) > -1;
                }
            },
            methods: {
                getVegaSpec(index) {
                    let newVegaSpec = JSON.parse(JSON.stringify(this.vegaSpec));
                    newVegaSpec.data.values = this.graphData[index];
                    return newVegaSpec;
                },
                checkIndex() {
                    if (this.index < 4) {
                        this.collapsed = false;
                    } else {
                        this.collapsed = true;
                    }
                },
                pin() {
                    this.arrayToggle(this.others.pins[this.patientIndex], this.name)
                },
                flag() {
                    this.arrayToggle(this.others.flags[this.patientIndex], this.name)
                },
                arrayToggle(array, value) {
                    let index = array.indexOf(value);
                    if (array.indexOf(value) < 0) {
                        array.push(value);
                    } else {
                        array.splice(index, 1);
                    }
                }
            },
            mounted() {
                this.checkIndex();
            },
        });
    </script>
    <template id="data-card-template">
        <div :class="{'data-card': true, 'data-card_mini': collapsed, 'data-card_warn':warn, 'data-card_flag': flagged}"
            @click="collapsed = !collapsed">
            <div class="data-card__flex">
                <p class="data-card__title data-card__left">{{name}}</p>
                <p class="data-card__text" v-if="!collapsed">{{latest.Category}}</p>
            </div>
            <div class="data-card__flex">
                <p v-if="!collapsed" class="data-card__time-main data-card__left">Last completed
                    {{fromToday(latest.ServiceDate)}}
                    <p v-else class="data-card__time-main data-card__left">{{fromToday(latest.ServiceDate)}}
                    </p>
                    <p class="data-card__time">{{formatDate(latest.ServiceDate)}}</p>
            </div>
            <div class="data-card__values" v-if="!collapsed">
                <template v-for="(result, index) in latest.results">
                    <template v-if="result.type === 'number'">
                        <div :class="{'data-card__name-con': true, 'warn': warnValues[index]} ">
                            <p class="data-card__value-name">{{result.testValue}}</p>
                            <div class="data-card__line"></div>
                        </div>
                        <!-- <div></div> -->
                        <vega class="data-card__bar-con" :spec="getVegaSpec(index)"></vega>

                        <p :class="{'data-card__value': true, 'warn': warnValues[index]}">{{result.value}}</p>
                        <p :class="{'data-card__value-unit': true, 'warn': warnValues[index]}">{{result.units}}</p>
                    </template>
                    <template v-if="result.type === 'image'">
                        <div class="data-card__image-con">
                            <p class="data-card__notes">{{result.notes}}</p>
                            <div class="data-card__image">
                                <img :src="'scanTests/'+result.link" alt="">
                            </div>
                        </div>
                    </template>
                </template>
            </div>
            <div class="data-card__buttons" v-if="!collapsed">
                <button class="data-card__more" v-if="pined" @click.stop="pin">Unpin</button>
                <button class="data-card__more" v-else @click.stop="pin">Pin</button>
                <button class="data-card__more" v-if="flagged" @click.stop="flag">Unflag</button>
                <button class="data-card__more" v-else @click.stop="flag">Flag</button>
                <p class="data-card__more" v-if="numNotShowing > 0">{{numNotShowing}} past results not displayed</p>
                <template v-else>
                    <p class="data-card__more data-card__more_faded" v-if="numIsShowing > 1">showing all
                        {{numIsShowing}} results</p>
                    <p class="data-card__more data-card__more_faded" v-else>showing the only result</p>
                </template>
            </div>
        </div>
    </template>

    <script>
        Vue.component('category', {
            template: '#category-template',
            props: {
                data: Array,
                type: Number,
                today: Object,
                patientIndex: Number,
                others: Object,
            },
            data() {
                return {
                    searchRaw: '',
                    tagsSelected: [],
                }
            },
            computed: {
                title() {
                    let types = [
                        'Laboratories',
                        'Imaging',
                        'Others',
                    ]
                    return types[this.type];
                },
                mostOftenWord() {
                    let words = [];
                    this.data.forEach(d => {
                        d.value.forEach(d => {
                            words = words.concat(d.Procedure.split(/ |\(|\)|,|-/));
                        });

                    });

                    // remove blank words
                    words = words.filter(d => d !== '' && d.length > 2);

                    // words = words.map(d => d.toLowerCase());

                    let grouped = d3.nest()
                        .key(d => d)
                        .rollup(d => d.length)
                        .entries(words);

                    grouped.sort((a, b) => b.value - a.value);

                    return grouped;
                },
                search() {
                    return this.searchRaw.trim();
                },
                fuzz() {
                    return new Fuse(this.data, {
                        keys: ['key', 'value.results.testValue'],
                        threshold: 0.2
                    });
                },
                filteredData() {

                    let filtered = this.data;
                    if (this.search.length > 0) {
                        filtered = this.fuzz.search(this.search);
                    }

                    if (this.tagsSelected.length > 0) {
                        filtered = filtered.filter(d => {
                            let tagMatched = false;
                            this.tagsSelected.forEach(tag => {
                                let lowerCase = tag.toLowerCase();
                                if (d.key.toLowerCase().includes(lowerCase)) {
                                    tagMatched = true;
                                }
                                if (d.value[0].Category.toLowerCase().includes(lowerCase)) {
                                    tagMatched = true;
                                }
                            });
                            return tagMatched;
                        });
                    }

                    return filtered;
                }
            },
            methods: {
                toggleTag(tag) {
                    let tagIndex = this.tagsSelected.indexOf(tag)
                    if (tagIndex > -1) {
                        delete this.tagsSelected.splice(tagIndex, 1);
                    } else {
                        this.tagsSelected.push(tag);
                    }
                },
                pin(item) {
                    this.$emit('pin', item);
                }
            },
        });
    </script>
    <template id="category-template">
        <div class="category">
            <p class="category__title">{{title}}</p>
            <div class="filter">
                <input class="filter__input" placeholder="Search" v-model="searchRaw">
                <div :class="[{'filter__tags' : true, 'filter__tags_selected' : tagsSelected.indexOf(tag.key) > -1}]"
                    v-for="tag in mostOftenWord.slice(0,10)" v-on:click="toggleTag(tag.key)">{{tag.key}}</div>
            </div>
            <div class="category__cards-con">
                <div class="category__cards-track">
                    <transition-group name="list" class="category__scroll">
                        <data-card v-for="(item, index) in filteredData" :data="item" :key="item.key" :type="type"
                            :today="today" :index="index" :patient-index="patientIndex" :others="others"></data-card>
                    </transition-group>
                </div>
                <div class="category__shadow"></div>
            </div>
        </div>
    </template>

    <script>
        new Vue({
            el: '#app',
            data: {
                doctor: {
                    firstName: "Jorge",
                    middleName: "L.",
                    lastName: "Weaver",
                    type: "Physician",
                    id: "03578115",
                },
                patients: patients,
                patientIndex: 0,
                now: moment("2031 02 20", "YYYY MM DD"),
                today: moment("2031 02 20", "YYYY MM DD"),

                tabIndex: 0,

                tabs: [
                    'Overview',
                    'Clinical Documents',
                    'Clip Board',
                ],
                notesInput: "",

                others: others,
            },
            computed: {
                realTime() {
                    return this.now.diff(this.today, 'days', true) === 0;
                },
                patient() {
                    return patients[this.patientIndex];
                },
                patientOrderHistory() {
                    let filtered = this.patient.OrderEntry.filter(d => {
                        return this.momentParseDMY(d.ServiceDate).format('x') < this.today.format('x');
                    });
                    return filtered.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.ServiceDate).format('x');
                        return (dateB - dateA);
                    });
                },
                patientInfo() {

                    let birthDate = this.momentParseDMY(this.patient.Info.Birthday);
                    let age = this.today.diff(birthDate, 'years');

                    return {
                        firstName: this.patient.Info.FirstName,
                        middleName: this.patient.Info.MiddleName,
                        lastName: this.patient.Info.LastName,
                        id: this.patient.Info.ID,
                        gender: this.patient.Info.Gender,
                        age: age,
                    }
                },
                patientDietaryRestrictions() {
                    let filtered = this.patientOrderHistory.filter(d => d.Category === 'Dietary');

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
                patientLaboratories() {
                    let filtered = this.patientOrderHistory.filter(d => d.Category === 'Laboratory');

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
                patientImaging() {
                    let filtered = this.patientOrderHistory.filter(d => {
                        return (d.Category === 'Computed Tomography' || d.Category === 'Radiography' || d.Category === 'Ultrasonography');
                    });

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
                patientOthers() {
                    let filtered = this.patientOrderHistory.filter(d => {
                        return (
                            d.Category !== 'Laboratory' &&
                            d.Category !== 'Computed Tomography' &&
                            d.Category !== 'Radiography' &&
                            d.Category !== 'Ultrasonography' &&
                            d.Category !== 'Dietary'
                        )
                    });

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
            },
            methods: {
                changeDate(date) {
                    this.today = date;
                },
                keyDownManager(event) {
                    if (event.altKey) {
                        if (event.keyCode === 49) {
                            this.patientIndex = 0;
                        } else if (event.keyCode === 50) {
                            this.patientIndex = 1;
                        } else if (event.keyCode === 51) {
                            this.patientIndex = 2;
                        }
                    }
                },
            },
            mounted() {
                window.addEventListener('keydown', this.keyDownManager);
            }
        })
    </script>
</body>

</html>