<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Condensed&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="main.css">

    <title>Document</title>
</head>

<body>
    <div id="app">
        <div class="sidebar">
            <p class="sidebar__name-large">{{patientInfo.lastName}}</p>
            <p class="sidebar__name-small">{{patientInfo.firstName}} {{patientInfo.middleName}}</p>
            <p class="sidebar__title">ID {{patientInfo.id}}</p>
            <p class="sidebar__text">{{patientInfo.gender}}, Age {{patientInfo.age}}</p>
            <div class="sidebar__line"></div>
            <p class="sidebar__title">Chief Complaint</p>
            <p class="sidebar__text">{{patient.EDM.ChiefComplaint}}</p>
            <p class="sidebar__title">Dietary Restrictions</p>
            <div v-for="restriction in patientDietaryRestrictions.slice(0,3)">
                <p class="sidebar__text">{{restriction.key}}</p>
                <p class="sidebar__text">{{fromToday(restriction.value[0].ServiceDate)}}</p>
            </div>
            <p class="sidebar__title">Current Medications</p>
            <p class="sidebar__title">Allergies</p>
            <div class="sidebar__line"></div>
            <p class="sidebar__title">Notes</p>
        </div>
        <div class="main">
            <div class="content">
                <div class="overview">
                    <category class="category_lab" :type="0" :data="patientLaboratories" :today="today"></category>
                    <category class="category_imaging" :type="1" :data="patientImaging" :today="today"></category>
                    <category class="category_other" :type="2" :data="patientOthers" :today="today"></category>
                </div>
            </div>

            <timeline :data="patient"></timeline>
        </div>
    </div>



    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://momentjs.com/downloads/moment.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.6.1/fuse.min.js"></script>
    <script src="https://unpkg.com/vue-vega"></script>

    <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>

    <script src="fake_patient_data.js"></script>
    <script src="sample_tests.js"></script>



    <script>
        let randomFromRange = (range) => {
            let rangeValues = range.split('-');
            let min = Math.min(rangeValues[0], rangeValues[1]);
            let max = Math.max(rangeValues[0], rangeValues[1]);
            return ((Math.random() * (max - min)) + min);
        }

        // data cleaning
        patients.forEach(patient => {
            patient.OrderEntry.forEach(entry => {
                if (entry.Category === 'Laboratory') {
                    let results = []

                    let prams = sample_tests[entry.Procedure];
                    if (prams !== undefined) {
                        prams.forEach(pram => {
                            let value = randomFromRange(pram.range);

                            let result = {
                                testValue: pram.testValue,
                                range: pram.range,
                                units: pram.units,
                                type: pram.type,
                                value: value.toFixed(2),
                            };
                            results.push(result)
                        });
                    }

                    entry.results = results;
                }
            });
        });

        Vue.use(VueVega.default);

        Vue.mixin({
            methods: {
                momentParseDMY(date) {
                    return moment(date, 'DD-MMMM-YYYY');
                },
                momentParseDMYT(date) {
                    return moment(date, 'DD-MMMM-YYYY HH:mm');
                },
                formatDate(date) {
                    return this.momentParseDMY(date).format("MMM Do, YYYY");
                },
                fromToday(date) {
                    return this.momentParseDMY(date).from(this.today);
                },
            }
        });
    </script>

    <script>
        Vue.component('timeline', {
            template: '#timeline-template',
            props: {
                data: Object,
            },
            computed: {
                timeData() {
                    let chronologicalData = [];
                    let date = null;
                    let index = 0;

                    date = this.momentParseDMYT(this.data.EDM.ArrivalTime);
                    index = chronologicalData.push(this.data.EDM) - 1;
                    chronologicalData[index].parsedDate = date;
                    chronologicalData[index].from = 'EDM';

                    date = this.momentParseDMYT(this.data.ADM.AdmitTime);
                    index = chronologicalData.push(this.data.ADM) - 1;
                    chronologicalData[index].parsedDate = date;
                    chronologicalData[index].from = 'ADM';

                    this.data.OrderEntry.forEach(d => {
                        let date = this.momentParseDMY(d.ServiceDate);
                        let index = chronologicalData.push(d) - 1;
                        chronologicalData[index].parsedDate = date;
                        chronologicalData[index].from = 'OrderEntry';
                    });
                    this.data.Appointments.forEach(d => {
                        let date = this.momentParseDMY(d.Date);
                        let index = chronologicalData.push(d) - 1;
                        chronologicalData[index].parsedDate = date;
                        chronologicalData[index].from = 'Appointments';
                    });
                    this.data.EDMLocationHistory.forEach(d => {
                        let date = this.momentParseDMYT(d.StartDate);
                        let index = chronologicalData.push(d) - 1;
                        chronologicalData[index].parsedDate = date;
                        chronologicalData[index].from = 'EDMLocationHistory';
                    });
                    this.data.ADMLocationHistory.forEach(d => {
                        let date = this.momentParseDMYT(d.StartDate);
                        let index = chronologicalData.push(d) - 1;
                        chronologicalData[index].parsedDate = date;
                        chronologicalData[index].from = 'ADMLocationHistory';
                    });
                    this.data.Surgeries.forEach(d => {
                        let date = this.momentParseDMYT(d.PatientInRoom);
                        let index = chronologicalData.push(d) - 1;
                        chronologicalData[index].parsedDate = date;
                        chronologicalData[index].from = 'Surgeries';
                    });

                    chronologicalData.sort((a, b) => {
                        return a.parsedDate.unix() - b.parsedDate.unix();
                    });

                    let bundledData = [];
                    let bundleTemplate = {
                        startDate: null,
                        endDate: null,
                        type: '',
                        niceName: '',
                        items: [],
                    };
                    let nameMapping = {
                        EDM: 'Emergency',
                        ADM: 'Transfer to Hospital',
                        OrderEntry: '',
                        Appointments: 'Visited',
                        EDMLocationHistory: 'Room Change',
                        ADMLocationHistory: 'Room Change',
                        Surgeries: 'Surgery',
                    }
                    let bundle = null;
                    chronologicalData.forEach(d => {
                        if (bundle === null || bundle.type !== d.from) {
                            if (bundle !== null) {
                                bundle.endDate = d.parsedDate;
                                bundledData.push(bundle);
                            }

                            bundle = JSON.parse(JSON.stringify(bundleTemplate));

                            bundle.type = d.from;
                            bundle.niceName = nameMapping[d.from];
                            bundle.startDate = d.parsedDate;
                            bundle.items = [];
                        }
                        bundle.items.push(d);
                    });

                    return bundledData;
                },
            },
            methods: {
                eventClassGen(type) {
                    let classObject = {};
                    classObject['timeline__event'] = true;
                    classObject['timeline__event_' + type] = true;
                    return classObject;
                }
            },
            mounted() {
                this.$refs.line.scrollLeft = this.$refs.line.scrollWidth;
            }
        });
    </script>
    <template id="timeline-template">
        <div class="timeline" ref="line">
            <div class="timeline__track">
                <div :class="eventClassGen(event.type)" v-for="event in timeData">
                    {{event.niceName}}
                </div>
            </div>
        </div>
    </template>

    <script>
        Vue.component('vega', {
            template: '#vega-template',
            props: {
                spec: Object,
            },
            watch: {
                spec: {
                    handler(newSpec, oldSpec) {
                        this.vega(newSpec);
                    },
                    deep: true,
                }
            },
            methods: {
                vega(spec) {
                    this.$refs.graph.innerHtml = "";
                    vegaEmbed.embed(this.$refs.graph, spec, {
                        actions: false,
                        renderer: 'svg',
                    });
                }
            },
            mounted() {
                this.vega(this.spec);
            }
        });
    </script>
    <template id="vega-template">
        <div class="vega" ref="graph"></div>
    </template>


    <script>
        Vue.component('data-card', {
            template: '#data-card-template',
            props: {
                data: Object,
                type: Number,
                today: Object,
            },
            data() {
                return {
                    vega: {
                        background: 'transparent',
                        config: {
                            view: {
                                stroke: "transparent"
                            }
                        },
                        mark: {
                            type: "line",
                            interpolate: "monotone",
                            strokeWidth: 1,
                            point: {
                                filled: true,
                                stroke: "white",
                                strokeWidth: 1,
                                size: 20,
                            },
                        },
                        data: { values: null },
                        width: 'container',
                        height: 'container',
                        padding: 0,
                        encoding: {
                            x: {
                                field: 'date',
                                type: 'temporal',
                                axis: null,
                            },
                            y: {
                                field: 'delta',
                                type: 'quantitative',
                                axis: null,
                            },
                            color: {
                                value: '#1F1424',
                            },
                            tooltip: [
                                { field: "value", type: "quantitative" },
                                { field: "delta", type: "quantitative" },
                                { field: "date", type: "temporal" },
                            ]
                        },
                    }
                }
            },
            computed: {
                latest() {
                    return this.data.value[0];
                },
                maxDelta() {
                    let max = [];
                    this.latest.results.forEach((d, index) => {
                        max.push(d3.max(this.data.value.map(d => Math.abs(this.latest.results[index].value - d.results[index].value))));
                    });
                    return max;
                },
                graphData() {
                    let data = [];
                    this.latest.results.forEach((d, index) => {
                        let resultData = [];
                        this.data.value.forEach(d => {
                            let delta = this.latest.results[index].value - d.results[index].value;
                            let date = d.ServiceDate;

                            resultData.push({
                                delta: delta,
                                value: d.results[index].value,
                                date: date,
                            });
                        });
                        data.push(resultData);
                    });
                    return data;
                },
            },
            methods: {
                getVegaSpec(index) {
                    let newVegaSpec = JSON.parse(JSON.stringify(this.vega));
                    newVegaSpec.data.values = this.graphData[index];
                    return newVegaSpec;
                }
            },
        });
    </script>
    <template id="data-card-template">
        <div class="data-card">
            <div class="data-card__flex">
                <p class="data-card__title data-card__left">{{data.key}}</p>
                <p class="data-card__text">{{latest.Category}}</p>
            </div>
            <div class="data-card__flex">
                <p class="data-card__time-main data-card__left">Last completed {{fromToday(latest.ServiceDate)}}
                </p>
                <p class="data-card__time">{{formatDate(latest.ServiceDate)}}</p>
            </div>
            <div class="data-card__values">
                <template class="data-card__test-item" v-for="(result, index) in latest.results">
                    <div class="data-card__name-con">
                        <p class="data-card__value-name">{{result.testValue}}</p>
                        <div class="data-card__line"></div>
                    </div>

                    <vega class="data-card__bar-con" :spec="getVegaSpec(index)"></vega>

                    <p class="data-card__value">{{result.value}}</p>
                    <p class="data-card__value-unit">{{result.units}}</p>
                </template>
            </div>
            <p class="data-card__more" v-if="data.value.length > 1">{{data.value.length}} more past results</p>
            <p class="data-card__more data-card__more_faded" v-else>no more results</p>
        </div>
    </template>

    <script>
        Vue.component('category', {
            template: '#category-template',
            props: {
                data: Array,
                type: Number,
                today: Object,
            },
            data() {
                return {
                    searchRaw: '',
                    tagsSelected: [],
                }
            },
            computed: {
                title() {
                    let types = [
                        'Laboratories',
                        'Imaging',
                        'Others',
                    ]
                    return types[this.type];
                },
                mostOftenWord() {
                    let words = [];
                    this.data.forEach(d => {
                        d.value.forEach(d => {
                            words = words.concat(d.Procedure.split(/ |\(|\)|,|-/));
                        });

                    });

                    // remove blank words
                    words = words.filter(d => d !== '' && d.length > 2);

                    // words = words.map(d => d.toLowerCase());

                    let grouped = d3.nest()
                        .key(d => d)
                        .rollup(d => d.length)
                        .entries(words);

                    grouped.sort((a, b) => b.value - a.value);

                    return grouped;
                },
                search() {
                    return this.searchRaw.trim();
                },
                fuzz() {
                    return new Fuse(this.data, {
                        keys: ['key', 'value.results.testValue'],
                        threshold: 0.2
                    });
                },
                filteredData() {

                    let filtered = this.data;
                    if (this.search.length > 0) {
                        filtered = this.fuzz.search(this.search);
                    }

                    if (this.tagsSelected.length > 0) {
                        filtered = filtered.filter(d => {
                            let tagMatched = false;
                            this.tagsSelected.forEach(tag => {
                                let lowerCase = tag.toLowerCase();
                                if (d.key.toLowerCase().includes(lowerCase)) {
                                    tagMatched = true;
                                }
                                if (d.value[0].Category.toLowerCase().includes(lowerCase)) {
                                    tagMatched = true;
                                }
                            });
                            return tagMatched;
                        });
                    }

                    return filtered;
                }
            },
            methods: {
                toggleTag(tag) {
                    let tagIndex = this.tagsSelected.indexOf(tag)
                    if (tagIndex > -1) {
                        delete this.tagsSelected.splice(tagIndex, 1);
                    } else {
                        this.tagsSelected.push(tag);
                    }
                }
            },
        });
    </script>
    <template id="category-template">
        <div class="category">
            <p class="category__title">{{title}}</p>
            <div class="filter">
                <input class="filter__input" placeholder="Search" v-model="searchRaw">
                <div :class="[{'filter__tags' : true, 'filter__tags_selected' : tagsSelected.indexOf(tag.key) > -1}]"
                    v-for="tag in mostOftenWord.slice(0,10)" v-on:click="toggleTag(tag.key)">{{tag.key}}</div>
            </div>
            <div class="category__cards-con">
                <transition-group name="list" class="category__scroll">
                    <data-card v-for="(item, index) in filteredData" :data="item" :key="item.key" :type="type"
                        :today="today"></data-card>
                </transition-group>
                <div class="category__shadow"></div>
            </div>
        </div>
    </template>

    <script>
        new Vue({
            el: '#app',
            data: {
                doctor: {
                    firstName: "Jorge",
                    middleName: "L.",
                    lastName: "Weaver",
                    type: "Physician",
                    id: "03578115",
                },
                patients: patients,
                patientIndex: 0,
            },
            computed: {
                patient() {
                    return patients[this.patientIndex];
                },
                today() {
                    return moment("2031 02 20", "YYYY MM DD");
                },
                patientOrderHistory() {
                    return this.patient.OrderEntry.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.ServiceDate).format('x');
                        return (dateB - dateA);
                    });
                },
                patientInfo() {

                    let birthDate = this.momentParseDMY(this.patient.Info.Birthday);
                    let age = this.today.diff(birthDate, 'years');

                    return {
                        firstName: this.patient.Info.FirstName,
                        middleName: this.patient.Info.MiddleName,
                        lastName: this.patient.Info.LastName,
                        id: this.patient.Info.ID,
                        gender: this.patient.Info.Gender,
                        age: age,
                    }
                },
                patientDietaryRestrictions() {
                    let filtered = this.patientOrderHistory.filter(d => d.Category === 'Dietary');

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
                patientLaboratories() {
                    let filtered = this.patientOrderHistory.filter(d => d.Category === 'Laboratory');

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
                patientImaging() {
                    let filtered = this.patientOrderHistory.filter(d => {
                        return (d.Category === 'Computed Tomography' || d.Category === 'Radiography');
                    });

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
                patientOthers() {
                    let filtered = this.patientOrderHistory.filter(d => {
                        return (
                            d.Category !== 'Laboratory' &&
                            d.Category !== 'Computed T' &&
                            d.Category !== 'Radiography' &&
                            d.Category !== 'Dietary'
                        )
                    });

                    let combined = d3.nest()
                        .key(d => d.Procedure)
                        .rollup(d => d)
                        .entries(filtered);

                    let sorted = combined.sort((a, b) => {
                        let dateA = this.momentParseDMY(a.value[0].ServiceDate).format('x');
                        let dateB = this.momentParseDMY(b.value[0].ServiceDate).format('x');
                        return (dateB - dateA);
                    });

                    return sorted;
                },
            },
        })
    </script>
</body>

</html>